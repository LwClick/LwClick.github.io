<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="一、学习指南1. 为什么要用集合为了⽅便操作多个对象，那么我们就得把这多个对象存储起来，想要存储多个对象(变量)，很容易就能想到⼀个容器(集合)来装载 Java给我们提供了工具方便我们去操作多个Java对象。  需要了解的数据结构：数组，链表，散列表，红黑树 2. 结论 如果是集合类型，有List和Set可供选择 List：插入有序的，元素是可重复的。一般用子类ArrayList或者LinkedL">
<meta property="og:type" content="article">
<meta property="og:title" content="集合">
<meta property="og:url" content="http://yoursite.com/2020/05/15/%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="绝对领域">
<meta property="og:description" content="一、学习指南1. 为什么要用集合为了⽅便操作多个对象，那么我们就得把这多个对象存储起来，想要存储多个对象(变量)，很容易就能想到⼀个容器(集合)来装载 Java给我们提供了工具方便我们去操作多个Java对象。  需要了解的数据结构：数组，链表，散列表，红黑树 2. 结论 如果是集合类型，有List和Set可供选择 List：插入有序的，元素是可重复的。一般用子类ArrayList或者LinkedL">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200419192821.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200419202741.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200419205757.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420131320.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420131523.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420131745.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420131959.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132103.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132559.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132739.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132840.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132925.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132129.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420133454.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/20200420133610.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/20200420133800.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420134350.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420135319.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420135807.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420140300.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420140825.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420140914.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420140950.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420141117.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420143050.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420145933.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/2-3.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/11.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420152749.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420153433.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420153936.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154020.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154211.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154340.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154412.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154444.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420155433.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420155615.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160231.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160308.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160410.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160430.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420161844.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420162325.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164037.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164105.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164116.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164127.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164344.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164855.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420165053.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/image-20200420165140095.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170237.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170438.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170526.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170537.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170544.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170552.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170739.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170843.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170909.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420171028.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205155.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205406.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205509.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205549.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205636.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205704.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205928.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210057.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210123.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210242.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210326.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210345.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210500.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421211449.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421212935.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420172642.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213435.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213453.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213501.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213512.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213524.png">
<meta property="og:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213534.png">
<meta property="article:published_time" content="2020-05-15T13:00:09.000Z">
<meta property="article:modified_time" content="2020-05-15T13:00:22.875Z">
<meta property="article:author" content="xCoding">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200419192821.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/15/集合/"/>





  <title>集合 | 绝对领域</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">绝对领域</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">lwclick</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/15/%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xCoding">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://gitee.com/lwclick/blogImg/raw/master/img/959e5d02246fb23f5d5f613f7767eeac.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="绝对领域">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">集合</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-15T21:00:09+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/fighting/" itemprop="url" rel="index">
                    <span itemprop="name">fighting</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/05/15/%E9%9B%86%E5%90%88/" class="leancloud_visitors" data-flag-title="集合">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="一、学习指南"><a href="#一、学习指南" class="headerlink" title="一、学习指南"></a>一、学习指南</h3><h4 id="1-为什么要用集合"><a href="#1-为什么要用集合" class="headerlink" title="1. 为什么要用集合"></a>1. 为什么要用集合</h4><p>为了⽅便操作多个对象，那么我们就得把这多个对象存储起来，想要存储多个对象(变量)，很容易就能想到⼀个容器(集合)来装载</p>
<p><strong>Java给我们提供了工具方便我们去操作多个Java对象。</strong></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200419192821.png" alt="TIM截图20200419192821"></p>
<p><strong>需要了解的数据结构</strong>：数组，链表，散列表，红黑树</p>
<h4 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h4><ul>
<li>如果是集合类型，有List和Set可供选择<ul>
<li>List：插入有序的，元素是可重复的。一般用子类ArrayList或者LinkedList</li>
<li>Set：插入无序的，元素不可重复。一般用HashSet或者TreeSet</li>
</ul>
</li>
<li>如果是Key - Value型，选择map<ul>
<li>LinkedHashMap：保持插入顺序</li>
<li>HashMap：不保持插入顺序</li>
<li>TreeMap：可以排序</li>
</ul>
</li>
</ul>
<h4 id="3-面试前一定要看回顾和阅读源码"><a href="#3-面试前一定要看回顾和阅读源码" class="headerlink" title="3. 面试前一定要看回顾和阅读源码"></a>3. 面试前一定要看回顾和阅读源码</h4><hr>
<h3 id="二、Collection"><a href="#二、Collection" class="headerlink" title="二、Collection"></a>二、Collection</h3><h4 id="1-集合（Collection）介绍"><a href="#1-集合（Collection）介绍" class="headerlink" title="1. 集合（Collection）介绍"></a>1. 集合（Collection）介绍</h4><h5 id="1-1-为什么需要Collection"><a href="#1-1-为什么需要Collection" class="headerlink" title="1.1 为什么需要Collection"></a>1.1 为什么需要Collection</h5><ul>
<li><p>Java是⼀⻔⾯向对象的语⾔，就免不了处理对象</p>
</li>
<li><p>为了⽅便操作多个对象，那么我们就得把这多个对象存储起来      <strong>容器</strong></p>
</li>
<li><p>常用的容器有：StringBuffer，数组</p>
</li>
</ul>
<h5 id="1-2-StringBuffer-和-StringBuiler类"><a href="#1-2-StringBuffer-和-StringBuiler类" class="headerlink" title="1.2 StringBuffer 和 StringBuiler类"></a>1.2 StringBuffer 和 StringBuiler类</h5><ul>
<li><p>String 类是不可改变的，所以一旦创建了 String 对象，那它的值就无法改变了</p>
</li>
<li><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
</li>
<li><p>StringBuffer ：线程安全的</p>
</li>
<li><p>StringBuilder ：有速度优势，线程不安全</p>
</li>
</ul>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200419202741.png" alt="TIM截图20200419202741" style="zoom:65%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">"菜鸟教程官网："</span>);</span><br><span class="line">    sBuffer.append(<span class="string">"www"</span>);</span><br><span class="line">    sBuffer.append(<span class="string">".lwclick"</span>);</span><br><span class="line">    sBuffer.append(<span class="string">".com"</span>);</span><br><span class="line">    System.out.println(sBuffer);   【www.lwclick.com】</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"abc"</span>;                 <span class="comment">// 常量池</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);     <span class="comment">// 堆内存中</span></span><br><span class="line">System.out.println(s1==s2);        <span class="comment">// false两个对象的地址值不一样。</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h5 id="1-3-数组和集合的区别"><a href="#1-3-数组和集合的区别" class="headerlink" title="1.3 数组和集合的区别"></a>1.3 数组和集合的区别</h5><ul>
<li>数组<ul>
<li>长度固定</li>
<li>存储基本数据类型，也可以存储引用类型</li>
</ul>
</li>
<li>集合<ul>
<li>长度可变</li>
<li>只能存储引用类型（存储int，会自动装箱成Integer）</li>
</ul>
</li>
</ul>
<h5 id="1-4-Collection主要学习内容"><a href="#1-4-Collection主要学习内容" class="headerlink" title="1.4 Collection主要学习内容"></a>1.4 Collection主要学习内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">	--List</span><br><span class="line">		---ArrayList</span><br><span class="line">		---Vector</span><br><span class="line">		---LinkedList</span><br><span class="line">	--Set</span><br><span class="line">		---HashSet</span><br><span class="line">		---TreeSet</span><br></pre></td></tr></table></figure>



<h5 id="1-5-Collection的功能"><a href="#1-5-Collection的功能" class="headerlink" title="1.5 Collection的功能"></a>1.5 Collection的功能</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">	boolean add(Object obj)：添加一个元素</span><br><span class="line">	boolean addAll(Collection c)：添加一个集合的元素</span><br><span class="line">	</span><br><span class="line">删除：</span><br><span class="line">	void clear()：移除所有元素</span><br><span class="line">	boolean remove(Object)：移除一个元素</span><br><span class="line">	boolean removeAll(Collection c)：移除一个集合的元素，只要有一个元素被移除了，就返回true</span><br><span class="line">	</span><br><span class="line">判断：</span><br><span class="line">	boolean contains(Object o)：判断集合是否包含该元素</span><br><span class="line">	boolean containsAll(Collection c)：判断集合中是否包含指定集合元素，只有包含所有才叫包含</span><br><span class="line">	boolean isEmpty()：判断集合是否为空</span><br><span class="line">	</span><br><span class="line">获取：</span><br><span class="line">	Iterator&lt;E&gt; iterator()：迭代器</span><br><span class="line">	</span><br><span class="line">长度：</span><br><span class="line">	int size()：元素个数</span><br><span class="line">	</span><br><span class="line">交集：</span><br><span class="line">	boolean retainAll(Collection c)：移除此集合中未包含在指定集合中的所有元素</span><br><span class="line">		A和B做交集，最终结果保存在A中，返回值表示A是否发生过变化</span><br></pre></td></tr></table></figure>



<h4 id="2-迭代器（Iterator）"><a href="#2-迭代器（Iterator）" class="headerlink" title="2. 迭代器（Iterator）"></a>2. 迭代器（Iterator）</h4><p>遍历集合中的元素，具体实现是在ArrayList以内部类的方式</p>
<ul>
<li>Collection的源码中继承了Iterable，Iterable是⼀个接⼝，有iterator()这个⽅法，返回的是Iterator</li>
<li>Iterator也是⼀个接⼝，它只有三个⽅法：hasNext()，next()，remove()</li>
</ul>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200419205757.png" alt="TIM截图20200419205757"></p>
<h4 id="3-List（interface）集合介绍"><a href="#3-List（interface）集合介绍" class="headerlink" title="3. List（interface）集合介绍"></a>3. List（interface）集合介绍</h4><ul>
<li><strong>特点</strong>：有序（存储顺序和取出顺序一致），可重复，返回的是ListIterator接⼝</li>
<li>常用的子类：<ul>
<li>ArrayList：底层使用数组，线程不安全</li>
<li>LinkedList：链表，线程不安全</li>
<li>Vector：数组，线程安全</li>
</ul>
</li>
</ul>
<h4 id="4-Set集合介绍"><a href="#4-Set集合介绍" class="headerlink" title="4. Set集合介绍"></a>4. Set集合介绍</h4><ul>
<li><strong>特点</strong>：元素不可重复</li>
<li>常用子类：<ul>
<li>HashSet：哈希表（是一个元素为链表的数组）</li>
<li>TreeSet：红黑树（自平衡的二叉树），保证了元素的排序方式</li>
<li>LinkedHashSet：哈希表和链表</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、List集合"><a href="#三、List集合" class="headerlink" title="三、List集合"></a>三、List集合</h3><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420131320.png" alt="TIM截图20200420131320" style="zoom:50%;" />

<h4 id="1-ArrayList解析"><a href="#1-ArrayList解析" class="headerlink" title="1. ArrayList解析"></a>1. ArrayList解析</h4><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420131523.png" alt="TIM截图20200420131523" style="zoom:50%;" />

<h5 id="1-1-属性"><a href="#1-1-属性" class="headerlink" title="1.1 属性"></a>1.1 属性</h5><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420131745.png" alt="TIM截图20200420131745" style="zoom:80%;" />

<p><strong>ArrayList底层其实就是⼀个数组</strong></p>
<h5 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h5><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420131959.png" alt="TIM截图20200420131959" style="zoom:80%;" />



<h5 id="1-3-Add方法"><a href="#1-3-Add方法" class="headerlink" title="1.3 Add方法"></a>1.3 Add方法</h5><h6 id="1-3-1-add-E-e"><a href="#1-3-1-add-E-e" class="headerlink" title="1.3.1 add(E e)"></a>1.3.1 add(E e)</h6><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132103.png" alt="TIM截图20200420132103"></p>
<p>步骤：</p>
<ul>
<li>检查是否需要扩容，确认list容量，尝试容量加1，看有无必要</li>
<li>插⼊元素</li>
</ul>
<p>查看小容量是否满足需求：</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132559.png" alt="TIM截图20200420132559"></p>
<p>调用了<code>ensureExplicitCapacity()</code>来确定明确的容量</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132739.png" alt="TIM截图20200420132739"></p>
<p>grow()实现扩容操作</p>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420132840.png" alt="TIM截图20200420132840" style="zoom:80%;" />

<p>copyOf()方法：</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132925.png" alt="TIM截图20200420132925"></p>
<p><strong>基本实现</strong></p>
<ul>
<li>首先检查数组的容量是否足够<ul>
<li>足够：直接添加</li>
<li>不够：扩容<ul>
<li>扩容到原来的1.5倍</li>
<li>第⼀次扩容后，如果容量还是⼩于minCapacity，就将容量扩充为minCapacity。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="1-3-2-add-int-index-E-element"><a href="#1-3-2-add-int-index-E-element" class="headerlink" title="1.3.2 add(int index, E element)"></a>1.3.2 add(int index, E element)</h6><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420132129.png" alt="TIM截图20200420132129"></p>
<p>步骤：</p>
<ul>
<li>检查角标</li>
<li>空间检查，如果有需要进行扩容</li>
<li>插入元素</li>
</ul>
<p>与扩容相关ArrayList的add⽅法底层其实都是arraycopy() 来实现的，该⽅法是由C/C++来编写的</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420133454.png" alt="TIM截图20200420133454"></p>
<h5 id="1-4-get方法"><a href="#1-4-get方法" class="headerlink" title="1.4 get方法"></a>1.4 get方法</h5><img src="https://gitee.com/lwclick/blogImg/raw/master/img/20200420133610.png" alt="20200420133610" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查⻆标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回元素</span></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-5-set方法"><a href="#1-5-set方法" class="headerlink" title="1.5 set方法"></a>1.5 set方法</h5><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/20200420133800.png" alt="20200420133800"></p>
<p>检查角标，        替代元素，         返回旧值</p>
<h5 id="1-6-remove方法"><a href="#1-6-remove方法" class="headerlink" title="1.6 remove方法"></a>1.6 remove方法</h5><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420134350.png" alt="TIM截图20200420134350" style="zoom:80%;" />

<p>检查⻆标，        删除元素，      计算出需要移动的个数，并移动，      设置为null，让Gc回收</p>
<h5 id="1-7-细节说明"><a href="#1-7-细节说明" class="headerlink" title="1.7 细节说明"></a>1.7 细节说明</h5><ul>
<li>ArrayList是基于动态数组实现的，在增删时候，需要数组的拷⻉复制。</li>
<li>ArrayList的<strong>默认初始化容量是10</strong>，每次扩容时候增加原先容量的⼀半，也就是变为原来的1.5倍</li>
<li>删除元素时不会减少容量，若希望减少容量则调⽤trimToSize()</li>
<li>它不是线程安全的。它能存放null值。</li>
</ul>
<h4 id="2-Vector与ArrayList的区别"><a href="#2-Vector与ArrayList的区别" class="headerlink" title="2. Vector与ArrayList的区别"></a>2. Vector与ArrayList的区别</h4><ul>
<li><p>vector是JDK1.2的类</p>
</li>
<li><p>Vector底层也是数组，与ArrayList最⼤的区别就是：<strong>同步(线程安全)</strong></p>
</li>
<li><p>在要求⾮同步的情况下，我们⼀般都是使⽤ArrayList来替代Vector</p>
</li>
<li><p>如果想要ArrayList实现同步，可以使⽤Collections的⽅法： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list &#x3D; Collections.synchronizedList(new ArrayList(...))；</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vector底层数组不够⽤时，是扩展1倍</p>
</li>
</ul>
<h4 id="3-LinkedList解析"><a href="#3-LinkedList解析" class="headerlink" title="3. LinkedList解析"></a>3. LinkedList解析</h4><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420135319.png" alt="TIM截图20200420135319" style="zoom:60%;" />

<h5 id="3-1-属性"><a href="#3-1-属性" class="headerlink" title="3.1 属性"></a>3.1 属性</h5><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420135807.png" alt="TIM截图20200420135807"></p>
<p>底层是<strong>双向链表</strong>，LinkedList还实现了Deque接⼝，因此，我们可以操作LinkedList像操作队列和栈⼀样</p>
<p>有了头结点，其他的数据我们都可以获取得到了。</p>
<ul>
<li>transient int size = 0；</li>
<li>transient Node<E> first；</li>
<li>transient Node<E> last；</li>
</ul>
<h5 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h5><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420140300.png" alt="TIM截图20200420140300"></p>
<p>还有一个无参空构造方法</p>
<h5 id="3-3-add方法（往链表最后添加元素）"><a href="#3-3-add方法（往链表最后添加元素）" class="headerlink" title="3.3 add方法（往链表最后添加元素）"></a>3.3 add方法（往链表最后添加元素）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    	first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-4-remove方法"><a href="#3-4-remove方法" class="headerlink" title="3.4 remove方法"></a>3.4 remove方法</h5><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420140825.png" alt="TIM截图20200420140825" style="zoom:80%;" />

<p>unlink方法</p>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420140914.png" alt="TIM截图20200420140914" style="zoom:80%;" />

<p>相当于：</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420140950.png" alt="TIM截图20200420140950"></p>
<h5 id="3-5-get方法"><a href="#3-5-get方法" class="headerlink" title="3.5 get方法"></a>3.5 get方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420141117.png" alt="TIM截图20200420141117" style="zoom:80%;" />



<h5 id="3-6-set方法"><a href="#3-6-set方法" class="headerlink" title="3.6 set方法"></a>3.6 set方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-List集合总结"><a href="#4-List集合总结" class="headerlink" title="4. List集合总结"></a>4. List集合总结</h4><ul>
<li>ArrayList:<ul>
<li>底层实现是数组</li>
<li>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的⼀半，也就是变为原来的1.5倍</li>
<li>在增删时候，需要数组的拷⻉复制(navite ⽅法由C/C++实现)</li>
</ul>
</li>
<li>LinkedList:<ul>
<li>底层实现是双向链表（双向链表⽅便实现往前遍历）</li>
</ul>
</li>
<li>Vector:<ul>
<li>底层是数组，现在已少⽤，被ArrayList替代<ul>
<li>Vector所有⽅法都是同步，<strong>有性能损失</strong></li>
<li>Vector初始length是10 超过length时 以double倍增⻓，<strong>相比于ArrayList更多消耗内存</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>查询多用ArrayList，增删多用LinkedList</strong></p>
<hr>
<h3 id="四、Map集合"><a href="#四、Map集合" class="headerlink" title="四、Map集合"></a>四、Map集合</h3><p>只要有key，就能找到与之对应的value</p>
<h4 id="1-Map和Collection的区别"><a href="#1-Map和Collection的区别" class="headerlink" title="1. Map和Collection的区别"></a>1. Map和Collection的区别</h4><ul>
<li><p>Map集合的特点：</p>
<ul>
<li>将键映射到值的对象，一个键只能映射到一个值</li>
</ul>
</li>
<li><p>Map和Collection集合的区别：</p>
<ul>
<li>Map存储元素是成对出现的，key是唯一的，value可以重复</li>
<li>Collection存储元素是单独出现的，Set是唯一的，List是可重复的</li>
</ul>
</li>
<li><p>要点：</p>
<ul>
<li>Map集合的数据结构针对键有效，跟值无关</li>
<li>Collection集合的数据结构针对元素有效</li>
</ul>
</li>
</ul>
<h4 id="2-Map的功能"><a href="#2-Map的功能" class="headerlink" title="2. Map的功能"></a>2. Map的功能</h4><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420143050.png" alt="TIM截图20200420143050" style="zoom:80%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">添加：</span><br><span class="line">	V put(K key, V value):添加元素</span><br><span class="line">		如果键是第一次存储，就直接存储value，返回null</span><br><span class="line">		否则的话，用新的value替换掉原来的value，返回以前的值</span><br><span class="line">		</span><br><span class="line">删除：</span><br><span class="line">	void clear():移除所有的键值对元素</span><br><span class="line">	V remove(Object key):根据key删除value，并把value返回</span><br><span class="line">	</span><br><span class="line">判断：</span><br><span class="line">	boolean containsKey(Object key):判断集合是否包含指定的键</span><br><span class="line">	boolean containsValue(Object value):判断集合是否包含指定的值</span><br><span class="line">	boolean isEmpty():判断集合是否为空</span><br><span class="line">	</span><br><span class="line">获取：</span><br><span class="line">	【Set&lt;Map.Entry&lt;K key, V value&gt; entrySet&gt;&gt; entrySet():返回的是键值对对象的集合】</span><br><span class="line">	V get(Object key):根据键获得值</span><br><span class="line">	Set&lt;K&gt; keySet():获取集合中所有的键的集合</span><br><span class="line">	Collection&lt;V&gt; values():获取集合中所有的值得集合</span><br><span class="line">	</span><br><span class="line">长度：</span><br><span class="line">	int size():返回集合中键值对的对数</span><br></pre></td></tr></table></figure>



<h4 id="3-散列表介绍"><a href="#3-散列表介绍" class="headerlink" title="3. 散列表介绍"></a>3. 散列表介绍</h4><ul>
<li><p>数组和链表：存储的顺序和取出的顺序是⼀致的，想要获取某个元素，就要访问所有的元素，直到找到为⽌</p>
</li>
<li><p>散列表（哈希表）：不在意元素的顺序，能够快速的查找元素的数据，<strong>通过数组+链表实现</strong></p>
</li>
</ul>
<h5 id="3-1-工作原理"><a href="#3-1-工作原理" class="headerlink" title="3.1 工作原理"></a>3.1 工作原理</h5><p>散列表为每个对象计算出⼀个整数，称为<strong>散列码</strong>。根据这些计算出来的散列码<strong>保存在对应的位置上</strong>！</p>
<p>散列表⽤的是链表数组实现的，每个列表称之为桶</p>
<p><strong>⼀个桶</strong>上可能会遇到<strong>被占用的情况</strong>(hashCode散列码相同，就存储在同⼀个位置上)  ==&gt; 散列冲突</p>
<h5 id="3-2-散列冲突"><a href="#3-2-散列冲突" class="headerlink" title="3.2 散列冲突"></a>3.2 散列冲突</h5><p>⼀个桶上可能会遇到被占⽤的情况，此时需要⽤该对象与桶上的对象进⾏⽐较，看看该对象是否存在桶⼦上了~如果存在，就不添加了，如果不存在则添加到桶⼦上</p>
<p><strong>在JDK1.8中，桶满时会从链表变成平衡⼆叉树</strong></p>
<p>如果散列表太满，是需要对散列表再散列，创建⼀个桶数更多的散列表，并将原有的元素插⼊到新表中，丢弃原来的表</p>
<ul>
<li>装填因⼦(load factor)决定了何时对散列表再散列</li>
<li>装填因⼦默认为0.75，如果表中超过了75%的位置已经填⼊了元素，那么这个表就会⽤双倍的桶数⾃动进⾏再散列</li>
</ul>
<h4 id="4-红黑树介绍"><a href="#4-红黑树介绍" class="headerlink" title="4. 红黑树介绍"></a>4. 红黑树介绍</h4><p>散列表中已经提过了：如果桶数满的时候，JDK8是将链表转成红⿊树的。并且，我们的TreeSet、TreeMap底层都是红⿊树来实现的。</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420145933.png" alt="TIM截图20200420145933"></p>
<h5 id="4-1-平衡树"><a href="#4-1-平衡树" class="headerlink" title="4.1 平衡树"></a>4.1 平衡树</h5><p>红⿊树就是⼀种平衡树，它可以保证⼆叉树基本符合<strong>矮矮胖胖(均衡)</strong>的结构</p>
<h5 id="4-2-2-3树"><a href="#4-2-2-3树" class="headerlink" title="4.2 2-3树"></a>4.2 2-3树</h5><ol>
<li><p>2-3树的意思就是说，一个父节点可以有两个子节点，也可以有三个子节点，并且其也满足类似<code>二叉搜索树</code>的定义（父节点的值大于左子树，但小于右子树），所有叶子节点都在同一层。</p>
</li>
<li><p>2节点：父节点存储一个值，最多有左右两个子树。</p>
</li>
<li><p>3节点：父节点存储两个值，最多有左中右三个子树</p>
</li>
</ol>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/2-3.png" alt="2-3" style="zoom:80%;" />

<p><strong>⼆叉查找树</strong>上，我们插⼊节点的过程是这样的：⼩于节点值往右继续与左⼦节点⽐，⼤于则继续与右⼦节点⽐，直到某节点左或右⼦节点为空，把值插⼊进去。这样<strong>⽆法避免偏向问题</strong></p>
<p><strong>2-3树</strong>：它插⼊的时候可以保持树的平衡！</p>
<ul>
<li>合并2-节点为3-节点，扩充将3-节点扩充为⼀个4-节点</li>
<li>分解4-节点为3-节点，节点3-节点为2-节点</li>
<li>⾄使得树平衡~</li>
</ul>
<h5 id="4-3-从2-3树到红黑树"><a href="#4-3-从2-3树到红黑树" class="headerlink" title="4.3 从2-3树到红黑树"></a>4.3 从2-3树到红黑树</h5><p>红黑树是对2-3查找树的改进，它能用一种<strong>统一的方式完成所有变换</strong>。</p>
<p>红黑树是一种<strong>平衡二叉树</strong>，因此它没有3-节点</p>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/11.png" alt="11" style="zoom:33%;" />

<p>红黑树也是平衡树的一种，在插入元素的时候它也得保持树的平衡，那红黑树是以什么的方式来保持树的平衡呢？</p>
<ul>
<li><p><strong>旋转</strong>：顺时针旋转和逆时针旋转</p>
</li>
<li><p><strong>反色</strong>：交换红黑的颜色</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">遵守这些约束的才能叫做红黑树：</span><br><span class="line">	1. 红黑树是二叉搜索树。</span><br><span class="line">    2. 根节点是黑色。</span><br><span class="line">    3. 【每个叶子节点都是黑色的空节点（NIL节点）】。</span><br><span class="line">    4. 【每个红色节点的两个子节点都是黑色】(从每个叶子到根的所有路径上不能有两个连续的红色节点)</span><br><span class="line">    5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点(每一条树链上的黑色节点数量（称之为“黑高”）必须相等)。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="五、HashMap"><a href="#五、HashMap" class="headerlink" title="五、HashMap"></a>五、HashMap</h3><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420152749.png" alt="TIM截图20200420152749" style="zoom:80%;" />

<ul>
<li>允许为null，     不保证有序 </li>
<li>底层由<strong>散列表实现</strong></li>
<li><strong>1.8之前：数组+链表，1.8之后：链表长度大于阀值（默认8），将链表转化为红黑树，减少搜索时间</strong></li>
<li>除了允许为null和同步以外，跟hashTable没区别</li>
<li>初始容量太高和装载因子太低对遍历都不好</li>
<li>当初始容量 * 装载因子小于哈希表的容量时，哈希表会再进行散列，桶数*2</li>
<li>装载因子默认是0.75，设置高虽然会减少空间，但遍历时，开销会增大</li>
<li>如果知道有足够多的数据存到hashmap中，最好设置初始容量</li>
</ul>
<h4 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h4><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420153433.png" alt="TIM截图20200420153433" style="zoom:80%;" />



<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420153936.png" alt="TIM截图20200420153936"></p>
<p>调用了<code>tableSizeFor()</code></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154020.png" alt="TIM截图20200420154020"></p>
<p>threshold这个成员变量是阈值，决定了是否要将散列表再散列。它的值应该是：<code>capacity * load factor</code>才对的，这里仅仅是一个初始化，当创建哈希表的时候，它会重新赋值的</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154211.png" alt="TIM截图20200420154211"></p>
<h4 id="3-put方法（重点）"><a href="#3-put方法（重点）" class="headerlink" title="3. put方法（重点）"></a>3. put方法（重点）</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154340.png" alt="TIM截图20200420154340"></p>
<p>计算哈希值</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154412.png" alt="TIM截图20200420154412"></p>
<p>做异或运算</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420154444.png" alt="TIM截图20200420154444"></p>
<p>我们是根据key的哈希值来保存在散列表中的，表默认的初始容量是16，要放到散列表中，就是0-15的位置上。</p>
<p>也就是<code>tab[i = (n - 1) &amp; hash]</code>。可以发现的是：在做<code>&amp;</code>运算的时候，仅仅是<strong>后4位有效</strong></p>
<p>那如果我们key的哈希值高位变化很大，低位变化很小。直接拿过去做<code>&amp;</code>运算，这就会导致计算出来的Hash值相同的很多。</p>
<p><strong>将key的哈希值的高位也做了运算(与高16位做异或运算，使得在做&amp;运算时，此时的低位实际上是高位与低位的结合)，这就增加了随机性</strong>，减少了碰撞冲突的可能性！</p>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420155433.png" alt="TIM截图20200420155433" style="zoom:80%;" />

<p>在初始化的时候要调用这个方法，当散列表元素大于<code>capacity * load factor</code>的时候也是调用<code>resize()</code></p>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420155615.png" alt="TIM截图20200420155615" style="zoom:80%;" />



<h4 id="4-get方法"><a href="#4-get方法" class="headerlink" title="4. get方法"></a>4. get方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160231.png" alt="TIM截图20200420160231"></p>
<p>getNode方法<img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160308.png" alt="TIM截图20200420160308"></p>
<h4 id="5-remove方法"><a href="#5-remove方法" class="headerlink" title="5. remove方法"></a>5. remove方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160410.png" alt="TIM截图20200420160410"></p>
<p>removeNode</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420160430.png" alt="TIM截图20200420160430"></p>
<h4 id="6-HashMap与Hashtable对比"><a href="#6-HashMap与Hashtable对比" class="headerlink" title="6. HashMap与Hashtable对比"></a>6. HashMap与Hashtable对比</h4><ul>
<li>从存储结构和实现来讲基本上都是相同的。</li>
<li><strong>Hashtable是线程安全的</strong>，另外它<strong>不允许key和value为null</strong>。</li>
<li>Hashtable是个过时的集合类，不建议在新代码中使⽤，不需要线程安全的场合可以⽤HashMap替换，需要<strong>线程安全</strong>的场合可以<strong>⽤ConcurrentHashMap替换</strong></li>
</ul>
<h4 id="7-HashMap总结"><a href="#7-HashMap总结" class="headerlink" title="7. HashMap总结"></a>7. HashMap总结</h4><ul>
<li><p>在JDK8中<strong>HashMap的底层</strong>是：数组+链表(散列表)+红⿊树</p>
</li>
<li><p>当<strong>装载因子*初始容量 &lt; 散列表元素</strong>时，该散列表会再散列，扩容2倍</p>
</li>
<li><p><strong>装载因⼦的默认值是0.75</strong></p>
<ul>
<li>装载因⼦初始值⼤了，可以减少散列表再散列(扩容的次数)，但同时会导致散列冲突的可能性变⼤</li>
<li>装载因⼦初始值⼩了，可以减⼩散列冲突的可能性，但同时扩容的次数可能就会变多</li>
</ul>
</li>
<li><p><strong>初始容量的默认值是16</strong></p>
<ul>
<li>初始容量过⼤，那么遍历时我们的速度就会受影响</li>
<li>初始容量过小，散列表再散列(扩容的次数)可能就变得多</li>
</ul>
</li>
<li><p><strong>HashMap并不是直接拿key的哈希值来用的，它会将key的哈希值的高16位进行异或操作，使得我们将元素放入哈希表的时候增加了一定的随机性</strong></p>
</li>
<li><p><strong><em>并不是桶⼦上有8位元素的时候它就能变成红⿊树，它得同时满⾜我们的散列表容量大于64才⾏（MIN_TREEIFY_CAPACITY）</em></strong></p>
</li>
</ul>
<hr>
<h3 id="六、LinkedHashMap"><a href="#六、LinkedHashMap" class="headerlink" title="六、LinkedHashMap"></a>六、LinkedHashMap</h3><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420161844.png" alt="TIM截图20200420161844" style="zoom:80%;" />

<ul>
<li>迭代有序，底层是<strong>散列表和双向链表</strong>，继承自hashmap</li>
<li>一个key被重新插入，顺序不受影响</li>
<li>插入位置有序</li>
<li>允许为null， 非同步</li>
</ul>
<h4 id="1-LinkedHashMap重写的方法"><a href="#1-LinkedHashMap重写的方法" class="headerlink" title="1. LinkedHashMap重写的方法"></a>1. LinkedHashMap重写的方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420162325.png" alt="TIM截图20200420162325"></p>
<p>在构建新节点时，构建的是<code>LinkedHashMap.Entry</code> 不再是<code>Node</code>.</p>
<h5 id="1-1-Map-Entry"><a href="#1-1-Map-Entry" class="headerlink" title="1.1 Map.Entry"></a>1.1 Map.Entry</h5><ul>
<li><p><strong>Map.Entry的定义。</strong></p>
<ul>
<li>Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键/值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。</li>
</ul>
</li>
<li><p>Map.Entry是为了更方便的输出map键值对。可以一次性获得key和value</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">map.put(<span class="string">"2"</span>, <span class="string">"v2"</span>);</span><br><span class="line">map.put(<span class="string">"3"</span>, <span class="string">"v3"</span>);</span><br><span class="line"></span><br><span class="line">【第一种】</span><br><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    sout(<span class="string">"key:"</span> + key + <span class="string">"value:"</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【第二种】</span><br><span class="line">Iterator&lt;map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">    sout(<span class="string">"key:"</span> + entry.getKey() + <span class="string">"value:"</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h4><p><strong>LinkedHashMap默认使用的是插入顺序</strong></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164037.png" alt="TIM截图20200420164037"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164105.png" alt="TIM截图20200420164105"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164116.png" alt="TIM截图20200420164116"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164127.png" alt="TIM截图20200420164127"></p>
<h4 id="3-put方法"><a href="#3-put方法" class="headerlink" title="3. put方法"></a>3. put方法</h4><p>LinkedHashMap的put方法和HashMap是一样的。</p>
<p><strong>在创建节点的时候，调用的是LinkedHashMap重写的方法</strong></p>
<h4 id="4-get方法-1"><a href="#4-get方法-1" class="headerlink" title="4. get方法"></a>4. get方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164344.png" alt="TIM截图20200420164344"></p>
<p><strong>最常用的将其放在链表的最后，不常用的放在链表的最前</strong></p>
<h4 id="5-remove方法-1"><a href="#5-remove方法-1" class="headerlink" title="5. remove方法"></a>5. remove方法</h4><p>对于remove方法，在LinkedHashMap中调用的还是父类的HashMap的<code>remove()</code>方法</p>
<p>在LinkedHashMap中重写的是：<code>afterNodeRemoval(Node e)</code>这个方法</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420164855.png" alt="TIM截图20200420164855"></p>
<h4 id="6-遍历的方法"><a href="#6-遍历的方法" class="headerlink" title="6. 遍历的方法"></a>6. 遍历的方法</h4><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>是被重写的了</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420165053.png" alt="TIM截图20200420165053"></p>
<img src="https://gitee.com/lwclick/blogImg/raw/master/img/image-20200420165140095.png" alt="image-20200420165140095" style="zoom:80%;" />

<p><strong>初始容量对遍历没有影响</strong>，因为它遍历的是<strong>LinkedHashMap内部维护的一个双向链表</strong>，而不是散列表</p>
<h4 id="7-LinkedHashMap总结"><a href="#7-LinkedHashMap总结" class="headerlink" title="7. LinkedHashMap总结"></a>7. LinkedHashMap总结</h4><ul>
<li><strong>LinkedHashMap比HashMap多了一个双向链表的维护</strong>，在数据结构而言它要复杂一些</li>
<li>LinkedHashMap并没有重写put方法，而put方法内部的<code>newNode()</code>方法重写了。LinkedHashMap调用父类的put方法，里面回调的是重写后的<code>newNode()</code>，从而达到目的</li>
<li>LinkedHashMap可以设置两种遍历顺序<ul>
<li>访问顺序（access-ordered）（ LRU(最近最少使用)算法的实现 ）</li>
<li>插入顺序（insertion-ordered）（默认）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="七、TreeMap"><a href="#七、TreeMap" class="headerlink" title="七、TreeMap"></a>七、TreeMap</h3><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420170237.png" alt="TIM截图20200420170237" style="zoom:80%;" />

<ul>
<li><strong>TreeMap是有序的</strong>：TreeMap实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口</li>
<li><strong>TreeMap底层是红黑树</strong>，它方法的时间复杂度都不会太高:log(n)</li>
<li>非同步</li>
<li>使用Comparator或者Comparable来比较key是否相等与排序的问题</li>
</ul>
<h4 id="1-属性-1"><a href="#1-属性-1" class="headerlink" title="1. 属性"></a>1. 属性</h4><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200420170438.png" alt="TIM截图20200420170438" style="zoom:80%;" />



<h4 id="2-构造方法-2"><a href="#2-构造方法-2" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170526.png" alt="TIM截图20200420170526"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170537.png" alt="TIM截图20200420170537"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170544.png" alt="TIM截图20200420170544"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170552.png" alt="TIM截图20200420170552"></p>
<p>TreeMap有序是通过Comparator来进行比较的，<strong>如果comparator为null，那么就使用自然顺序</strong>~</p>
<h4 id="3-put方法-1"><a href="#3-put方法-1" class="headerlink" title="3. put方法"></a>3. put方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170739.png" alt="TIM截图20200420170739"></p>
<p>下面是<code>compare(Object k1, Object k2)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares two keys using the correct comparison method for this TreeMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">            : comparator.compare((K)k1, (K)k2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-get方法-2"><a href="#4-get方法-2" class="headerlink" title="4. get方法"></a>4. get方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170843.png" alt="TIM截图20200420170843"></p>
<p>如果Comparator不为null，接下来我们进去看看<code>getEntryUsingComparator(Object key)</code>，是怎么实现的</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420170909.png" alt="TIM截图20200420170909"></p>
<h4 id="5-remove方法-2"><a href="#5-remove方法-2" class="headerlink" title="5. remove方法"></a>5. remove方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420171028.png" alt="TIM截图20200420171028"></p>
<h4 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6. 遍历"></a>6. 遍历</h4><p><strong>TreeMap遍历是使用EntryIterator这个内部类的</strong></p>
<h4 id="7-TreeMap总结"><a href="#7-TreeMap总结" class="headerlink" title="7. TreeMap总结"></a>7. TreeMap总结</h4><ul>
<li><strong>TreeMap底层是红黑树，能够实现该Map集合有序</strong>，时间复杂度可以保证为log(n)</li>
<li><strong>TreeMap非同步的</strong>，想要同步可以使用Collections来进行封装</li>
</ul>
<p>如果在构造方法中传递了Comparator对象，那么就会以Comparator对象的方法进行比较。否则，则使用Comparable的<code>compareTo(T o)</code>方法来比较</p>
<p>如果使用的是<code>compareTo(T o)</code>方法来比较，<strong>key一定是不能为null</strong>，并且得实现了Comparable接口的</p>
<hr>
<h3 id="八、ConcurrentHashMap"><a href="#八、ConcurrentHashMap" class="headerlink" title="八、ConcurrentHashMap"></a>八、ConcurrentHashMap</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><ul>
<li><strong>JDK1.8底层结构是   散列表(数组+链表)+红黑树</strong></li>
<li><strong>JDK1.7的底层是：segments+HashEntry数组</strong></li>
<li>而ConcurrentHashMap作为一个高并发的容器，它是通过<strong>部分锁定+CAS算法来进行实现线程安全的</strong>。CAS算法也可以认为是<strong>乐观锁</strong>的一种，hashtable是每个方法都加锁</li>
<li>ConCurrentHashMap支持<strong>高并发</strong>的访问和更新，它是<strong>线程安全</strong>的</li>
<li>在高并发环境下，统计数据(计算size…等等)其实是无意义的，因为在下一时刻size值就变化了</li>
<li><strong>get方法是非阻塞</strong>，无锁的。重写Node类，通过volatile修饰next来实现每次获取都是<strong>最新</strong>设置的值</li>
<li><strong>ConcurrentHashMap的key和Value都不能为null</strong></li>
</ul>
<h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>CAS（比较与交换，Compare and swap） 是一种有名的<strong>无锁算法</strong></p>
<p>有<strong>3个</strong>操作数</p>
<ul>
<li><strong>内存值V</strong></li>
<li><strong>旧的预期值A</strong></li>
<li><strong>要修改的新值B</strong></li>
</ul>
<p><strong>当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做</strong></p>
<ul>
<li>当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值(<strong>A和内存值V相同时，将内存值V修改为B)</strong>，而其它线程都失败，失败的线程<strong>并不会被挂起</strong>，而是被告知这次竞争中失败，并可以再次尝试<strong>(否则什么都不做)</strong></li>
</ul>
<h4 id="3-volatile关键字"><a href="#3-volatile关键字" class="headerlink" title="3. volatile关键字"></a>3. volatile关键字</h4><p><strong>volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性</strong></p>
<ul>
<li>保证<strong>该变量对所有线程的可见性</strong><ul>
<li>在多线程的环境下：当这个变量修改时，<strong>所有的线程都会知道该变量被修改了</strong>，也就是所谓的“可见性”</li>
</ul>
</li>
<li>不保证原子性<ul>
<li>修改变量(赋值)<strong>实质上</strong>是在JVM中<strong>分了好几步</strong>，而<strong>在这几步内(从装载变量到修改)，它是不安全的</strong>。</li>
</ul>
</li>
</ul>
<h4 id="4-域对象"><a href="#4-域对象" class="headerlink" title="4. 域对象"></a>4. 域对象</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205155.png" alt="TIM截图20200421205155"></p>
<h4 id="5-构造方法"><a href="#5-构造方法" class="headerlink" title="5. 构造方法"></a>5. 构造方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205406.png" alt="TIM截图20200421205406"></p>
<h4 id="6-put方法"><a href="#6-put方法" class="headerlink" title="6. put方法"></a>6. put方法</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205509.png" alt="TIM截图20200421205509"></p>
<p>初始化散列表的时候干了什么事：<code>initTable()</code></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205549.png" alt="TIM截图20200421205549"></p>
<h4 id="7-get方法"><a href="#7-get方法" class="headerlink" title="7. get方法"></a>7. get方法</h4><p>Node节点是重写的，设置了volatile关键字修饰，致使它每次获取的都是<strong>最新</strong>设置的值</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205636.png" alt="TIM截图20200421205636"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421205704.png" alt="TIM截图20200421205704"></p>
<hr>
<h3 id="九、Set"><a href="#九、Set" class="headerlink" title="九、Set"></a>九、Set</h3><h4 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h4><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200421205928.png" alt="TIM截图20200421205928" style="zoom:80%;" />

<p><strong>要点：</strong></p>
<ul>
<li>实现Set接口</li>
<li>不保证迭代顺序</li>
<li>允许元素为null</li>
<li><strong>底层实际上是一个HashMap实例</strong></li>
<li>非同步</li>
<li>初始容量非常影响迭代性能</li>
</ul>
<p>顶部注释说底层实际上是一个HashMap实例：</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210057.png" alt="TIM截图20200421210057"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210123.png" alt="TIM截图20200421210123"></p>
<h4 id="2-TreeSet"><a href="#2-TreeSet" class="headerlink" title="2. TreeSet"></a>2. TreeSet</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210242.png" alt="TIM截图20200421210242"></p>
<p><strong>要点：</strong></p>
<ul>
<li>实现NavigableSet接口</li>
<li>可以实现排序功能</li>
<li><strong>底层实际上是一个TreeMap实例</strong></li>
<li>非同步</li>
</ul>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210326.png" alt="TIM截图20200421210326"></p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421210345.png" alt="TIM截图20200421210345"></p>
<h4 id="3-LinkedHashSet"><a href="#3-LinkedHashSet" class="headerlink" title="3. LinkedHashSet"></a>3. LinkedHashSet</h4><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM截图20200421210500.png" alt="TIM截图20200421210500" style="zoom:80%;" />

<p><strong>要点：</strong></p>
<ul>
<li>迭代是有序的</li>
<li>允许为null</li>
<li><strong>底层实际上是一个HashMap+双向链表实例(其实就是LinkedHashMap)…</strong></li>
<li>非同步</li>
<li>性能比HashSet差一丢丢，因为要维护一个双向链表</li>
<li>初始容量与迭代无关，LinkedHashSet迭代的是双向链表</li>
</ul>
<h4 id="4-Set集合总结"><a href="#4-Set集合总结" class="headerlink" title="4. Set集合总结"></a>4. Set集合总结</h4><p><strong>Set集合的底层就是Map</strong></p>
<ul>
<li>HashSet：<ul>
<li>无序，允许为null，底层是HashMap（散列表+红黑树），非线程同步</li>
</ul>
</li>
<li>TreeSet：<ul>
<li>有序，不允许为null，底层是TreeMap（红黑树），非线程同步</li>
</ul>
</li>
<li>LinkedHashSet：<ul>
<li>迭代有序，允许为null，底层是HashMap+双向链表，非线程同步</li>
</ul>
</li>
</ul>
<hr>
<h3 id="十、CopyOnWriteArrayList"><a href="#十、CopyOnWriteArrayList" class="headerlink" title="十、CopyOnWriteArrayList"></a>十、CopyOnWriteArrayList</h3><h4 id="1-Vector和SynchronizedList"><a href="#1-Vector和SynchronizedList" class="headerlink" title="1. Vector和SynchronizedList"></a>1. Vector和SynchronizedList</h4><h5 id="1-1-线程安全的Vector和SynchronizedList"><a href="#1-1-线程安全的Vector和SynchronizedList" class="headerlink" title="1.1 线程安全的Vector和SynchronizedList"></a>1.1 线程安全的Vector和SynchronizedList</h5><p>如果使用 <code>Collections.synchronizedList(new ArrayList())</code> 来<strong>使ArrayList变成是线程安全</strong>的话，也是几乎都是每个方法都加上synchronized关键字的，只不过<strong>它不是加在方法的声明处，而是方法的内部</strong>。</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421211449.png" alt="TIM截图20200421211449"></p>
<h4 id="2-CopyOnWriteArrayList介绍"><a href="#2-CopyOnWriteArrayList介绍" class="headerlink" title="2. CopyOnWriteArrayList介绍"></a>2. CopyOnWriteArrayList介绍</h4><p>CopyOnWriteArrayList是<strong>同步List</strong>的替代品，CopyOnWriteArraySet是<strong>同步Set</strong>的替代品。</p>
<p>CopyOnWriteArraySet的原理就是CopyOnWriteArrayList。</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421212935.png" alt="TIM截图20200421212935"></p>
<h4 id="3-CopyOnWriteArrayList源码注释"><a href="#3-CopyOnWriteArrayList源码注释" class="headerlink" title="3. CopyOnWriteArrayList源码注释"></a>3. CopyOnWriteArrayList源码注释</h4><ul>
<li>CopyOnWriteArrayList是线程安全容器(相对于ArrayList)，底层通过<strong>复制数组</strong>的方式来实现。</li>
<li>CopyOnWriteArrayList在遍历的使用不会抛出ConcurrentModificationException异常，并且遍历的时候就不用额外加锁</li>
<li>元素可以为null</li>
<li><strong>底层就是数组，加锁就交由ReentrantLock来完成。</strong></li>
</ul>
<h4 id="4-常见方法"><a href="#4-常见方法" class="headerlink" title="4. 常见方法"></a>4. 常见方法</h4><p><strong>写加锁，读不加锁</strong></p>
<h5 id="4-1-add"><a href="#4-1-add" class="headerlink" title="4.1 add()"></a>4.1 add()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到原数组的长度和元素</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制出一个新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加时，将新元素添加到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将volatile Object[] array 的指向替换成新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在添加的时候就上锁，并<strong>复制一个新数组，增加操作在新数组上完成，将array指向到新数组中</strong>，最后解锁</p>
<h5 id="4-2-get"><a href="#4-2-get" class="headerlink" title="4.2 get()"></a>4.2 get()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-3-set"><a href="#4-3-set" class="headerlink" title="4.3 set()"></a>4.3 set()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到原数组的旧值</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断新值和旧值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制新数组，新值在新数组中完成</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将array引用指向新数组</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Not quite a no-op; enssures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-4-迭代器"><a href="#4-4-迭代器" class="headerlink" title="4.4 迭代器"></a>4.4 迭代器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 返回的迭代器是COWIterator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 迭代器的成员属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 迭代器的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    snapshot = elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 迭代器的方法...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.... 可以发现的是，迭代器所有的操作都基于snapshot数组，而snapshot是传递进来的array数组</span></span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList在使用迭代器遍历的时候，操作的都是<strong>原数组</strong></p>
<h4 id="5-CopyOnWriteArrayList缺点"><a href="#5-CopyOnWriteArrayList缺点" class="headerlink" title="5. CopyOnWriteArrayList缺点"></a>5. CopyOnWriteArrayList缺点</h4><ul>
<li><strong>内存占用</strong>：每次<code>add()、set()、remove()</code>这些增删改操作都要<strong>复制一个数组</strong>出来。</li>
<li><strong>数据一致性</strong>：CopyOnWrite容器<strong>只能保证数据的最终一致性，不能保证数据的实时一致性</strong>。</li>
</ul>
<h3 id="十一、面试题"><a href="#十一、面试题" class="headerlink" title="十一、面试题"></a>十一、面试题</h3><p>Java容器可分为两大类：</p>
<ul>
<li>Collection<ul>
<li>List<ul>
<li><strong>ArrayList</strong></li>
<li>LinkedList</li>
<li>Vector(了解，已过时)</li>
</ul>
</li>
<li>Set<ul>
<li><strong>HashSet</strong><ul>
<li>LinkedHashSet</li>
</ul>
</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map<ul>
<li><strong>HashMap</strong><ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable(了解，，已过时)</li>
</ul>
</li>
</ul>
<p>着重标出的那些就是我们<strong>用得最多</strong>的容器。</p>
<h4 id="1-ArrayList和Vector的区别"><a href="#1-ArrayList和Vector的区别" class="headerlink" title="1. ArrayList和Vector的区别"></a>1. ArrayList和Vector的区别</h4><p><strong>共同点：</strong></p>
<ul>
<li>这两个类都实现了List接口，它们都是<strong>有序</strong>的集合(存储有序)，<strong>底层是数组</strong>。我们可以按位置索引号取出某个元素，<strong>允许元素重复和为null</strong>。</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><strong>同步性：</strong><ul>
<li>ArrayList是非同步的</li>
<li>Vector是同步的</li>
<li>即便需要同步的时候，我们可以使用Collections工具类来构建出同步的ArrayList而不用Vector</li>
</ul>
</li>
<li><strong>扩容大小：</strong><ul>
<li>Vector增长原来的一倍，ArrayList增长原来的0.5倍</li>
</ul>
</li>
</ul>
<h4 id="2-HashMap和Hashtable的区别"><a href="#2-HashMap和Hashtable的区别" class="headerlink" title="2. HashMap和Hashtable的区别"></a>2. HashMap和Hashtable的区别</h4><p><strong>共同点：</strong></p>
<ul>
<li>从存储结构和实现来讲基本上都是相同的，都是实现Map接口~</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><strong>同步性：</strong><ul>
<li>HashMap是非同步的</li>
<li>Hashtable是同步的</li>
<li>需要同步的时候，我们往往不使用，而使用ConcurrentHashMap<a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484161&idx=1&sn=6f52fb1f714f3ffd2f96a5ee4ebab146&chksm=ebd74200dca0cb16288db11f566cb53cafc580e08fe1c570e0200058e78676f527c014ffef41#rd" target="_blank" rel="noopener">ConcurrentHashMap基于JDK1.8源码剖析</a></li>
</ul>
</li>
<li><strong>是否允许为null：</strong><ul>
<li>HashMap允许为null</li>
<li>Hashtable不允许为null</li>
</ul>
</li>
<li><strong>contains方法</strong><ul>
<li>这知识点是在牛客网刷到的，没想到这种题还会有(我不太喜欢)….</li>
<li>Hashtable有contains方法</li>
<li>HashMap把Hashtable的contains方法去掉了，改成了containsValue和containsKey</li>
</ul>
</li>
<li><strong>继承不同：</strong><ul>
<li>HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</li>
<li>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</li>
</ul>
</li>
</ul>
<h4 id="3-List和Map的区别"><a href="#3-List和Map的区别" class="headerlink" title="3. List和Map的区别"></a>3. List和Map的区别</h4><p><strong>共同点：</strong></p>
<ul>
<li>都是Java常用的容器，都是接口</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li><strong>存储结构不同</strong>：<ul>
<li>List是存储单列的集合</li>
<li>Map存储的是key-value键值对的集合</li>
</ul>
</li>
<li><strong>元素是否可重复</strong>：<ul>
<li>List允许元素重复</li>
<li>Map不允许key重复</li>
</ul>
</li>
<li><strong>是否有序</strong>：<ul>
<li>List集合是有序的(存储有序)</li>
<li>Map集合是无序的(存储无序)</li>
</ul>
</li>
</ul>
<h4 id="4-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals"><a href="#4-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals" class="headerlink" title="4. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?"></a>4. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?</h4><p>我们知道Set集合实际<strong>大都使用的是Map集合的put方法来添加元素</strong>。</p>
<p>以HashSet为例，HashSet里的元素不能重复，在源码(HashMap)是这样体现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1. 如果key 相等  </span><br><span class="line">  if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">      ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">      e &#x3D; p;</span><br><span class="line">&#x2F;&#x2F; 2. 修改对应的value</span><br><span class="line">   if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">          V oldValue &#x3D; e.value;</span><br><span class="line">          if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">              e.value &#x3D; value;</span><br><span class="line">          afterNodeAccess(e);</span><br><span class="line">          return oldValue;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>添加元素的时候，如果key(也对应的Set集合的元素)相等，那么则修改value值。而在Set集合中，value值仅仅是一个Object对象罢了(<strong>该对象对Set本身而言是无用的</strong>)。</p>
<p>也就是说：Set集合如果添加的元素相同时，<strong>是根本没有插入的(仅修改了一个无用的value值)</strong>！从源码(HashMap)中也看出来，<strong>==和equals()方法都有使用</strong>！</p>
<h4 id="5-Collection和Collections的区别"><a href="#5-Collection和Collections的区别" class="headerlink" title="5. Collection和Collections的区别"></a>5. Collection和Collections的区别</h4><ol>
<li>Collection是集合的上级<strong>接口</strong>，继承它的有Set和List接口</li>
<li>Collections是集合的<strong>工具类</strong>，提供了一系列的静态方法对集合的搜索、查找、同步等操作</li>
</ol>
<h4 id="6-说出ArrayList-LinkedList的存储性能和特性"><a href="#6-说出ArrayList-LinkedList的存储性能和特性" class="headerlink" title="6. 说出ArrayList,LinkedList的存储性能和特性"></a>6. 说出ArrayList,LinkedList的存储性能和特性</h4><p>ArrayList的底层是数组，LinkedList的底层是双向链表。</p>
<ul>
<li>ArrayList它支持以角标位置进行索引出对应的元素(随机访问)，而LinkedList则需要遍历整个链表来获取对应的元素。因此<strong>一般来说ArrayList的访问速度是要比LinkedList要快的</strong></li>
<li>ArrayList由于是数组，对于删除和修改而言消耗是比较大(复制和移动数组实现)，LinkedList是双向链表删除和修改只需要修改对应的指针即可，消耗是很小的。因此<strong>一般来说LinkedList的增删速度是要比ArrayList要快的</strong></li>
</ul>
<h5 id="6-1扩展："><a href="#6-1扩展：" class="headerlink" title="6.1扩展："></a>6.1扩展：</h5><p>ArrayList的增删<strong>未必</strong>就是比LinkedList要慢。</p>
<ul>
<li>如果增删都是在<strong>末尾</strong>来操作【每次调用的都是remove()和add()】，此时ArrayList就不需要移动和复制数组来进行操作了。如果数据量有百万级的时，<strong>速度是会比LinkedList要快的</strong>。(我测试过)</li>
<li>如果<strong>删除操作</strong>的位置是在<strong>中间</strong>。由于LinkedList的消耗主要是在遍历上，ArrayList的消耗主要是在移动和复制上(底层调用的是arraycopy()方法，是native方法)。<ul>
<li>LinkedList的遍历速度是要慢于ArrayList的复制移动速度的</li>
<li>如果数据量有百万级的时，<strong>还是ArrayList要快</strong>。(我测试过)</li>
</ul>
</li>
</ul>
<h4 id="7-Enumeration和Iterator接口的区别"><a href="#7-Enumeration和Iterator接口的区别" class="headerlink" title="7. Enumeration和Iterator接口的区别"></a>7. Enumeration和Iterator接口的区别</h4><p>只是大概知道的是：Iterator替代了Enumeration，Enumeration是一个旧的迭代器了。</p>
<p>与Enumeration相比，Iterator更加安全，<strong>因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合</strong>。</p>
<ul>
<li>我们在做练习的时候，迭代时会不会经常出错，抛出ConcurrentModificationException异常，说我们在遍历的时候还在修改元素。</li>
<li>这其实就是fail-fast机制~具体可参考博文：<a href="https://blog.csdn.net/panweiwei1994/article/details/77051261" target="_blank" rel="noopener">https://blog.csdn.net/panweiwei1994/article/details/77051261</a></li>
</ul>
<p><strong>区别有三点：</strong></p>
<ul>
<li>Iterator的方法名比Enumeration更科学</li>
<li>Iterator有fail-fast机制，比Enumeration更安全</li>
<li>Iterator能够删除元素，Enumeration并不能删除元素</li>
</ul>
<h4 id="8-ListIterator有什么特点"><a href="#8-ListIterator有什么特点" class="headerlink" title="8. ListIterator有什么特点"></a>8. ListIterator有什么特点</h4><ul>
<li>ListIterator<strong>继承了</strong>Iterator接口，它用于<strong>遍历List集合的元素</strong>。</li>
<li>ListIterator可以实现<strong>双向遍历,添加元素，设置元素</strong></li>
</ul>
<p>看一下源码的方法就知道了：</p>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200420172642.png" alt="TIM截图20200420172642"></p>
<h4 id="9-并发集合类是什么？"><a href="#9-并发集合类是什么？" class="headerlink" title="9. 并发集合类是什么？"></a>9. 并发集合类是什么？</h4><p>Java1.5并发包（java.util.concurrent）<strong>包含线程安全集合类，允许在迭代时修改集合</strong>。</p>
<ul>
<li>Utils包下的集合迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。但java.util.concurrent的并不会，感谢评论区提醒~</li>
<li>一部分类为：<ul>
<li>CopyOnWriteArrayList</li>
<li>ConcurrentHashMap</li>
<li>CopyOnWriteArraySet</li>
</ul>
</li>
</ul>
<h4 id="10-Java中HashMap的key值要是为类对象则该类需要满足什么条件？"><a href="#10-Java中HashMap的key值要是为类对象则该类需要满足什么条件？" class="headerlink" title="10. Java中HashMap的key值要是为类对象则该类需要满足什么条件？"></a>10. Java中HashMap的key值要是为类对象则该类需要满足什么条件？</h4><p><strong>需要同时重写该类的hashCode()方法和它的equals()方法</strong>。</p>
<ul>
<li>从源码可以得知，在插入元素的时候是<strong>先算出该对象的hashCode</strong>。如果hashcode相等话的。那么表明该对象是存储在同一个位置上的。</li>
<li>如果调用equals()方法，<strong>两个key相同</strong>，则<strong>替换元素</strong></li>
<li>如果调用equals()方法，<strong>两个key不相同</strong>，则说明该<strong>hashCode仅仅是碰巧相同</strong>，此时是散列冲突，将新增的元素放在桶子上</li>
</ul>
<p>一般来说，我们会认为：<strong>只要两个对象的成员变量的值是相等的，那么我们就认为这两个对象是相等的</strong>！因为，Object底层比较的是两个对象的地址，而对我们开发来说这样的意义并不大~这也就为什么我们要重写<code>equals()</code>方法</p>
<p>重写了equals()方法，就要重写hashCode()的方法。因为<strong>equals()认定了这两个对象相同</strong>，而<strong>同一个对象调用hashCode()方法时</strong>，是应该返回相同的值的！</p>
<h4 id="11-与Java集合框架相关的有哪些最好的实践"><a href="#11-与Java集合框架相关的有哪些最好的实践" class="headerlink" title="11. 与Java集合框架相关的有哪些最好的实践"></a>11. 与Java集合框架相关的有哪些最好的实践</h4><ol>
<li><strong>根据需要</strong>确定集合的类型。如果是单列的集合，我们考虑用Collection下的子接口ArrayList和Set。如果是映射，我们就考虑使用Map~</li>
<li>确定完我们的集合类型，我们接下来<strong>确定使用该集合类型下的哪个子类</strong>~我认为可以简单分成几个步骤：<ul>
<li>是否需要同步<ul>
<li>去找线程安全的集合类使用</li>
</ul>
</li>
<li>迭代时是否需要有序(插入顺序有序)<ul>
<li>去找Linked双向列表结构的</li>
</ul>
</li>
<li>是否需要排序(自然顺序或者手动排序)<ul>
<li>去找Tree红黑树类型的(JDK1.8) </li>
</ul>
</li>
</ul>
</li>
<li>估算存放集合的数据量有多大，无论是List还是Map，它们实现动态增长，都是有性能消耗的。在初始集合的时候给出一个<strong>合理的容量</strong>会减少动态增长时的消耗~</li>
<li><strong>使用泛型</strong>，避免在运行时出现ClassCastException</li>
<li>尽可能使用Collections工具类，或者获取只读、同步或空的集合，<strong>而非编写自己的实现</strong>。它将会提供代码重用性，它有着更好的稳定性和可维护性</li>
</ol>
<h4 id="12-ArrayList集合加入1万条数据，应该怎么提高效率"><a href="#12-ArrayList集合加入1万条数据，应该怎么提高效率" class="headerlink" title="12. ArrayList集合加入1万条数据，应该怎么提高效率"></a>12. ArrayList集合加入1万条数据，应该怎么提高效率</h4><p>ArrayList的默认初始容量为10，要插入大量数据的时候需要不断扩容，而扩容是非常影响性能的。因此，现在明确了10万条数据了，我们可以<strong>直接在初始化的时候就设置ArrayList的容量</strong>！</p>
<p>这样就可以提高效率了~</p>
<h4 id="13-集合框架底层实现总结"><a href="#13-集合框架底层实现总结" class="headerlink" title="13. 集合框架底层实现总结"></a>13. 集合框架底层实现总结</h4><ul>
<li>collection<ul>
<li>list<ul>
<li>arraylist：object数组</li>
<li>vector：object数组</li>
<li>LinkedList：双向链表</li>
</ul>
</li>
<li>set<ul>
<li>hashset（无序，唯一）：底层由hashmap实现</li>
<li>linkedhashset：继承于hashset，内部通过linkedhashmap来实现</li>
<li>treeset（有序，唯一）：红黑树（自平衡的有序二叉树）</li>
</ul>
</li>
<li>map<ul>
<li>hashmap：1.8之前：数组+链表，1.8之后：链表长度大于阀值（默认8），将链表转化为红黑树，减少搜索时间</li>
<li>linkedhashmap：继承自hashmap，在上面hashmap结构的基础上，增加了双向链表</li>
<li>hashtable：数组+链表组成，数组是hashmap的主体，链表为了解决哈希冲突</li>
<li>treemap：红黑树（自平衡的二叉树）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="14-各种对比"><a href="#14-各种对比" class="headerlink" title="14. 各种对比"></a>14. 各种对比</h4><p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213435.png" alt="TIM截图20200421213435"></p>
<hr>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213453.png" alt="TIM截图20200421213453"></p>
<hr>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213501.png" alt="TIM截图20200421213501"></p>
<hr>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213512.png" alt="TIM截图20200421213512"></p>
<hr>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213524.png" alt="TIM截图20200421213524"></p>
<hr>
<p><img src="https://gitee.com/lwclick/blogImg/raw/master/img/TIM%E6%88%AA%E5%9B%BE20200421213534.png" alt="TIM截图20200421213534"></p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="xCoding wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="xCoding 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="xCoding 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="next" title="多线程">
                <i class="fa fa-chevron-left"></i> 多线程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://gitee.com/lwclick/blogImg/raw/master/img/959e5d02246fb23f5d5f613f7767eeac.jpeg"
                alt="xCoding" />
            
              <p class="site-author-name" itemprop="name">xCoding</p>
              <p class="site-description motion-element" itemprop="description">change the world by code</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LwClick" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:Liu17663883288@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/" title="Baidu" target="_blank">Baidu</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.google.com.hk/" title="Google" target="_blank">Google</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、学习指南"><span class="nav-number">1.</span> <span class="nav-text">一、学习指南</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-为什么要用集合"><span class="nav-number">1.1.</span> <span class="nav-text">1. 为什么要用集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-结论"><span class="nav-number">1.2.</span> <span class="nav-text">2. 结论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-面试前一定要看回顾和阅读源码"><span class="nav-number">1.3.</span> <span class="nav-text">3. 面试前一定要看回顾和阅读源码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、Collection"><span class="nav-number">2.</span> <span class="nav-text">二、Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-集合（Collection）介绍"><span class="nav-number">2.1.</span> <span class="nav-text">1. 集合（Collection）介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-为什么需要Collection"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1 为什么需要Collection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-StringBuffer-和-StringBuiler类"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 StringBuffer 和 StringBuiler类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-数组和集合的区别"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.3 数组和集合的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-Collection主要学习内容"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.4 Collection主要学习内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-Collection的功能"><span class="nav-number">2.1.5.</span> <span class="nav-text">1.5 Collection的功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-迭代器（Iterator）"><span class="nav-number">2.2.</span> <span class="nav-text">2. 迭代器（Iterator）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-List（interface）集合介绍"><span class="nav-number">2.3.</span> <span class="nav-text">3. List（interface）集合介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Set集合介绍"><span class="nav-number">2.4.</span> <span class="nav-text">4. Set集合介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、List集合"><span class="nav-number">3.</span> <span class="nav-text">三、List集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ArrayList解析"><span class="nav-number">3.1.</span> <span class="nav-text">1. ArrayList解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-属性"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.1 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-构造方法"><span class="nav-number">3.1.2.</span> <span class="nav-text">1.2 构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-Add方法"><span class="nav-number">3.1.3.</span> <span class="nav-text">1.3 Add方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-3-1-add-E-e"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">1.3.1 add(E e)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#1-3-2-add-int-index-E-element"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">1.3.2 add(int index, E element)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-get方法"><span class="nav-number">3.1.4.</span> <span class="nav-text">1.4 get方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-set方法"><span class="nav-number">3.1.5.</span> <span class="nav-text">1.5 set方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-remove方法"><span class="nav-number">3.1.6.</span> <span class="nav-text">1.6 remove方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-细节说明"><span class="nav-number">3.1.7.</span> <span class="nav-text">1.7 细节说明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Vector与ArrayList的区别"><span class="nav-number">3.2.</span> <span class="nav-text">2. Vector与ArrayList的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-LinkedList解析"><span class="nav-number">3.3.</span> <span class="nav-text">3. LinkedList解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-属性"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.1 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-构造方法"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.2 构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-add方法（往链表最后添加元素）"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3 add方法（往链表最后添加元素）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-remove方法"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.4 remove方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-get方法"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.5 get方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-set方法"><span class="nav-number">3.3.6.</span> <span class="nav-text">3.6 set方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-List集合总结"><span class="nav-number">3.4.</span> <span class="nav-text">4. List集合总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、Map集合"><span class="nav-number">4.</span> <span class="nav-text">四、Map集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Map和Collection的区别"><span class="nav-number">4.1.</span> <span class="nav-text">1. Map和Collection的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Map的功能"><span class="nav-number">4.2.</span> <span class="nav-text">2. Map的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-散列表介绍"><span class="nav-number">4.3.</span> <span class="nav-text">3. 散列表介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-工作原理"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.1 工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-散列冲突"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.2 散列冲突</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-红黑树介绍"><span class="nav-number">4.4.</span> <span class="nav-text">4. 红黑树介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-平衡树"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.1 平衡树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-3树"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.2 2-3树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-从2-3树到红黑树"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.3 从2-3树到红黑树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、HashMap"><span class="nav-number">5.</span> <span class="nav-text">五、HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-属性"><span class="nav-number">5.1.</span> <span class="nav-text">1. 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-构造方法"><span class="nav-number">5.2.</span> <span class="nav-text">2. 构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-put方法（重点）"><span class="nav-number">5.3.</span> <span class="nav-text">3. put方法（重点）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-get方法"><span class="nav-number">5.4.</span> <span class="nav-text">4. get方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-remove方法"><span class="nav-number">5.5.</span> <span class="nav-text">5. remove方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-HashMap与Hashtable对比"><span class="nav-number">5.6.</span> <span class="nav-text">6. HashMap与Hashtable对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-HashMap总结"><span class="nav-number">5.7.</span> <span class="nav-text">7. HashMap总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、LinkedHashMap"><span class="nav-number">6.</span> <span class="nav-text">六、LinkedHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-LinkedHashMap重写的方法"><span class="nav-number">6.1.</span> <span class="nav-text">1. LinkedHashMap重写的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-Map-Entry"><span class="nav-number">6.1.1.</span> <span class="nav-text">1.1 Map.Entry</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-构造方法-1"><span class="nav-number">6.2.</span> <span class="nav-text">2. 构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-put方法"><span class="nav-number">6.3.</span> <span class="nav-text">3. put方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-get方法-1"><span class="nav-number">6.4.</span> <span class="nav-text">4. get方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-remove方法-1"><span class="nav-number">6.5.</span> <span class="nav-text">5. remove方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-遍历的方法"><span class="nav-number">6.6.</span> <span class="nav-text">6. 遍历的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-LinkedHashMap总结"><span class="nav-number">6.7.</span> <span class="nav-text">7. LinkedHashMap总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、TreeMap"><span class="nav-number">7.</span> <span class="nav-text">七、TreeMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-属性-1"><span class="nav-number">7.1.</span> <span class="nav-text">1. 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-构造方法-2"><span class="nav-number">7.2.</span> <span class="nav-text">2. 构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-put方法-1"><span class="nav-number">7.3.</span> <span class="nav-text">3. put方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-get方法-2"><span class="nav-number">7.4.</span> <span class="nav-text">4. get方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-remove方法-2"><span class="nav-number">7.5.</span> <span class="nav-text">5. remove方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-遍历"><span class="nav-number">7.6.</span> <span class="nav-text">6. 遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-TreeMap总结"><span class="nav-number">7.7.</span> <span class="nav-text">7. TreeMap总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、ConcurrentHashMap"><span class="nav-number">8.</span> <span class="nav-text">八、ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-总结"><span class="nav-number">8.1.</span> <span class="nav-text">1.总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CAS算法"><span class="nav-number">8.2.</span> <span class="nav-text">2. CAS算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-volatile关键字"><span class="nav-number">8.3.</span> <span class="nav-text">3. volatile关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-域对象"><span class="nav-number">8.4.</span> <span class="nav-text">4. 域对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-构造方法"><span class="nav-number">8.5.</span> <span class="nav-text">5. 构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-put方法"><span class="nav-number">8.6.</span> <span class="nav-text">6. put方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-get方法"><span class="nav-number">8.7.</span> <span class="nav-text">7. get方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、Set"><span class="nav-number">9.</span> <span class="nav-text">九、Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-HashSet"><span class="nav-number">9.1.</span> <span class="nav-text">1. HashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-TreeSet"><span class="nav-number">9.2.</span> <span class="nav-text">2. TreeSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-LinkedHashSet"><span class="nav-number">9.3.</span> <span class="nav-text">3. LinkedHashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Set集合总结"><span class="nav-number">9.4.</span> <span class="nav-text">4. Set集合总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十、CopyOnWriteArrayList"><span class="nav-number">10.</span> <span class="nav-text">十、CopyOnWriteArrayList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Vector和SynchronizedList"><span class="nav-number">10.1.</span> <span class="nav-text">1. Vector和SynchronizedList</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-线程安全的Vector和SynchronizedList"><span class="nav-number">10.1.1.</span> <span class="nav-text">1.1 线程安全的Vector和SynchronizedList</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-CopyOnWriteArrayList介绍"><span class="nav-number">10.2.</span> <span class="nav-text">2. CopyOnWriteArrayList介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-CopyOnWriteArrayList源码注释"><span class="nav-number">10.3.</span> <span class="nav-text">3. CopyOnWriteArrayList源码注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-常见方法"><span class="nav-number">10.4.</span> <span class="nav-text">4. 常见方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-add"><span class="nav-number">10.4.1.</span> <span class="nav-text">4.1 add()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-get"><span class="nav-number">10.4.2.</span> <span class="nav-text">4.2 get()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-set"><span class="nav-number">10.4.3.</span> <span class="nav-text">4.3 set()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-迭代器"><span class="nav-number">10.4.4.</span> <span class="nav-text">4.4 迭代器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-CopyOnWriteArrayList缺点"><span class="nav-number">10.5.</span> <span class="nav-text">5. CopyOnWriteArrayList缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一、面试题"><span class="nav-number">11.</span> <span class="nav-text">十一、面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ArrayList和Vector的区别"><span class="nav-number">11.1.</span> <span class="nav-text">1. ArrayList和Vector的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-HashMap和Hashtable的区别"><span class="nav-number">11.2.</span> <span class="nav-text">2. HashMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-List和Map的区别"><span class="nav-number">11.3.</span> <span class="nav-text">3. List和Map的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Set里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是equals"><span class="nav-number">11.4.</span> <span class="nav-text">4. Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Collection和Collections的区别"><span class="nav-number">11.5.</span> <span class="nav-text">5. Collection和Collections的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-说出ArrayList-LinkedList的存储性能和特性"><span class="nav-number">11.6.</span> <span class="nav-text">6. 说出ArrayList,LinkedList的存储性能和特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1扩展："><span class="nav-number">11.6.1.</span> <span class="nav-text">6.1扩展：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Enumeration和Iterator接口的区别"><span class="nav-number">11.7.</span> <span class="nav-text">7. Enumeration和Iterator接口的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-ListIterator有什么特点"><span class="nav-number">11.8.</span> <span class="nav-text">8. ListIterator有什么特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-并发集合类是什么？"><span class="nav-number">11.9.</span> <span class="nav-text">9. 并发集合类是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-Java中HashMap的key值要是为类对象则该类需要满足什么条件？"><span class="nav-number">11.10.</span> <span class="nav-text">10. Java中HashMap的key值要是为类对象则该类需要满足什么条件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-与Java集合框架相关的有哪些最好的实践"><span class="nav-number">11.11.</span> <span class="nav-text">11. 与Java集合框架相关的有哪些最好的实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-ArrayList集合加入1万条数据，应该怎么提高效率"><span class="nav-number">11.12.</span> <span class="nav-text">12. ArrayList集合加入1万条数据，应该怎么提高效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-集合框架底层实现总结"><span class="nav-number">11.13.</span> <span class="nav-text">13. 集合框架底层实现总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-各种对比"><span class="nav-number">11.14.</span> <span class="nav-text">14. 各种对比</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xCoding</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">
    总访问量：<span id="busuanzi_value_site_uv"></span>
</span>
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("6FvwPSgS2qi2N65NMEAkPoh2-gzGzoHsz", "S8r7yFHoBqgsyT8MP9bTGC1R");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
